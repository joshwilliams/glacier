m# Glacier
# Copyright 2012 Paul Engstler
# See LICENSE for details.

import time, utils, httplib, os, math, hashlib

class Request():

	"""

		This class takes care of signing each request properly. The following
		steps will be done:
			
			1. 	The Canonical Request is being generated.

			2. 	The String to Sign is being generated which contains
				the SHA-256 hash of the canonical request.

			3.	The signature is being generated by singing the
				String to Sign with the derived key.

			4.	The "Authorization" header is being built by
				combining the signature with the request.

	"""

	def __init__(self,connection,region,method,path,signed=[],header={},
		body=""):
		self.access_key = connection.access_key
		self.secret_access_key = connection.secret_access_key
		self.host = "glacier." + region + ".amazonaws.com"
		self.region = region
		self.method = method
		self.path = path
		self.header = self.build_header(header)
		self.signed_headers = ["host","x-amz-date","x-amz-glacier-version"]
		self.signed_headers.extend(signed)
		self.signed_headers.sort()
		self.body = body

	def hexhash(self,data):
		h = hashlib.sha256()
		h.update(data)
		return h.hexdigest()


	def canonical_request(self):
		# body is hashed here TODO
		req = self.method + "\n" + self.path + "\n\n"
		for hk in sorted(self.signed_headers):
			hv = self.header[hk]
			req += hk.lower()+":"+hv+"\n"
		req += "\n" + ";".join(self.signed_headers) + "\n"
		if not self.header.get("x-amz-content-sha256"):
			req += self.hexhash(self.body)
		else:
			req += self.header["x-amz-content-sha256"]
		return req

	def string_to_sign(self,canonical_request):	
		return "\n".join(["AWS4-HMAC-SHA256",self.header["x-amz-date"],
		"%(time)s/%(region)s/glacier/aws4_request\n%(hashthing)s" % {"time":utils.time("%Y%m%d"),"region": self.region,"hashthing":self.hexhash(canonical_request)}])
    
	def derived_key(self):
		kDate = utils.sign(("AWS4" + self.secret_access_key).encode("utf-8"),
		utils.time("%Y%m%d"))
		kRegion = utils.sign(kDate, self.region)
		kService = utils.sign(kRegion, "glacier")
		kSigning = utils.sign(kService, "aws4_request")
		return kSigning

	def signature(self,derivedkey,stringtosign):
		return utils.hmac_sha256(derivedkey,stringtosign)

	def build_authorization_header(self):
		cr = self.canonical_request()
		sts = self.string_to_sign(cr)
		dk = self.derived_key()
		sgn = self.signature(dk,sts)
		return "AWS4-HMAC-SHA256 Credential="+self.access_key+"/"+\
			utils.time("%Y%m%d")+"/"+self.region+\
			"/glacier/aws4_request,SignedHeaders="+\
			";".join(self.signed_headers)+\
			",Signature="+sgn
	
	def build_header(self,additional):
		header = {
			"host": self.host,
			"x-amz-glacier-version": "2012-06-01",
			"x-amz-date": utils.time("%Y%m%dT%H%M%SZ")
		}

		for key in additional.keys():
			header[key] = additional[key]	

		return header

	def send_request(self):
		
		# Because of the variety of hashes that need to be processed in the
		# Authorization header it will be baked last.
		self.header["Authorization"] = self.build_authorization_header()

		# Always via HTTPS!
		connection = httplib.HTTPSConnection(self.host)
		# uncomment if you want to debug the network i/o
		# connection.set_debuglevel(1)
		connection.connect()
		
		if isinstance(self.body,file):
			# stream the file in 10 MB chunks to keep the memory usage low
			self.body.seek(0)
			chunk_size = int(1024*1024*10)
			file_size = float(os.fstat(self.body.fileno()).st_size)
			chunk_count = int(math.ceil(file_size/float(chunk_size)))

			# send the data
			connection.request(self.method,self.path,"",self.header)
			for _ in range(chunk_count):
				connection.send(self.body.read(chunk_size))
		else:
			# send the whole body
			connection.request(self.method,self.path,self.body,self.header)

		return connection.getresponse()
